/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * FastAPI
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BodyDetectControlnetDetectPost
 */
export interface BodyDetectControlnetDetectPost {
    /**
     * 
     * @type {string}
     * @memberof BodyDetectControlnetDetectPost
     */
    controlnetModule?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BodyDetectControlnetDetectPost
     */
    controlnetInputImages?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof BodyDetectControlnetDetectPost
     */
    controlnetProcessorRes?: number;
    /**
     * 
     * @type {number}
     * @memberof BodyDetectControlnetDetectPost
     */
    controlnetThresholdA?: number;
    /**
     * 
     * @type {number}
     * @memberof BodyDetectControlnetDetectPost
     */
    controlnetThresholdB?: number;
}
/**
 * 
 * @export
 * @interface BodyLoginLoginPost
 */
export interface BodyLoginLoginPost {
    /**
     * 
     * @type {string}
     * @memberof BodyLoginLoginPost
     */
    grantType?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginLoginPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginLoginPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginLoginPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginLoginPost
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyLoginLoginPost
     */
    clientSecret?: string;
}
/**
 * 
 * @export
 * @interface ControlNetStableDiffusionProcessingImg2Img
 */
export interface ControlNetStableDiffusionProcessingImg2Img {
    /**
     * 
     * @type {Array<any>}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    initImages?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    resizeMode?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    denoisingStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    imageCfgScale?: number;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    mask?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    maskBlur?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    inpaintingFill?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    inpaintFullRes?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    inpaintFullResPadding?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    inpaintingMaskInvert?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    initialNoiseMultiplier?: number;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    prompt?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    styles?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    subseed?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    subseedStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    seedResizeFromH?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    seedResizeFromW?: number;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    samplerName?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    batchSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    nIter?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    steps?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    cfgScale?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    restoreFaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    tiling?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    doNotSaveSamples?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    doNotSaveGrid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    negativePrompt?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    eta?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    sChurn?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    sTmax?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    sTmin?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    sNoise?: number;
    /**
     * 
     * @type {any}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    overrideSettings?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    overrideSettingsRestoreAfterwards?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    scriptArgs?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    samplerIndex?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    includeInitImages?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    scriptName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    sendImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    saveImages?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    alwaysonScripts?: any;
    /**
     * ControlNet Processing Units
     * @type {Array<ControlNetUnitRequest>}
     * @memberof ControlNetStableDiffusionProcessingImg2Img
     */
    controlnetUnits?: Array<ControlNetUnitRequest>;
}
/**
 * 
 * @export
 * @interface ControlNetStableDiffusionProcessingTxt2Img
 */
export interface ControlNetStableDiffusionProcessingTxt2Img {
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    enableHr?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    denoisingStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    firstphaseWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    firstphaseHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    hrScale?: number;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    hrUpscaler?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    hrSecondPassSteps?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    hrResizeX?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    hrResizeY?: number;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    prompt?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    styles?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    subseed?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    subseedStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    seedResizeFromH?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    seedResizeFromW?: number;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    samplerName?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    batchSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    nIter?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    steps?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    cfgScale?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    restoreFaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    tiling?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    doNotSaveSamples?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    doNotSaveGrid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    negativePrompt?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    eta?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    sChurn?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    sTmax?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    sTmin?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    sNoise?: number;
    /**
     * 
     * @type {any}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    overrideSettings?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    overrideSettingsRestoreAfterwards?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    scriptArgs?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    samplerIndex?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    scriptName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    sendImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    saveImages?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    alwaysonScripts?: any;
    /**
     * ControlNet Processing Units
     * @type {Array<ControlNetUnitRequest>}
     * @memberof ControlNetStableDiffusionProcessingTxt2Img
     */
    controlnetUnits?: Array<ControlNetUnitRequest>;
}
/**
 * 
 * @export
 * @interface ControlNetUnitRequest
 */
export interface ControlNetUnitRequest {
    /**
     * 
     * @type {string}
     * @memberof ControlNetUnitRequest
     */
    inputImage?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlNetUnitRequest
     */
    mask?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlNetUnitRequest
     */
    module?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlNetUnitRequest
     */
    model?: string;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    weight?: number;
    /**
     * 
     * @type {number | string}
     * @memberof ControlNetUnitRequest
     */
    resizeMode?: number | string;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetUnitRequest
     */
    lowvram?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    processorRes?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    thresholdA?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    thresholdB?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    guidance?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    guidanceStart?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlNetUnitRequest
     */
    guidanceEnd?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControlNetUnitRequest
     */
    guessmode?: boolean;
}
/**
 * 
 * @export
 * @interface CreateResponse
 */
export interface CreateResponse {
    /**
     * Response string from create embedding or hypernetwork task.
     * @type {string}
     * @memberof CreateResponse
     */
    info: string;
}
/**
 * 
 * @export
 * @interface EmbeddingItem
 */
export interface EmbeddingItem {
    /**
     * The number of steps that were used to train this embedding, if available
     * @type {number}
     * @memberof EmbeddingItem
     */
    step?: number;
    /**
     * The hash of the checkpoint this embedding was trained on, if available
     * @type {string}
     * @memberof EmbeddingItem
     */
    sdCheckpoint?: string;
    /**
     * The name of the checkpoint this embedding was trained on, if available. Note that this is the name that was used by the trainer; for a stable identifier, use `sd_checkpoint` instead
     * @type {string}
     * @memberof EmbeddingItem
     */
    sdCheckpointName?: string;
    /**
     * The length of each individual vector in the embedding
     * @type {number}
     * @memberof EmbeddingItem
     */
    shape: number;
    /**
     * The number of vectors in the embedding
     * @type {number}
     * @memberof EmbeddingItem
     */
    vectors: number;
}
/**
 * 
 * @export
 * @interface EmbeddingsResponse
 */
export interface EmbeddingsResponse {
    /**
     * Embeddings loaded for the current model
     * @type {{ [key: string]: EmbeddingItem; }}
     * @memberof EmbeddingsResponse
     */
    loaded: { [key: string]: EmbeddingItem; };
    /**
     * Embeddings skipped for the current model (likely due to architecture incompatibility)
     * @type {{ [key: string]: EmbeddingItem; }}
     * @memberof EmbeddingsResponse
     */
    skipped: { [key: string]: EmbeddingItem; };
}
/**
 * 
 * @export
 * @interface Estimation
 */
export interface Estimation {
    /**
     * 
     * @type {string}
     * @memberof Estimation
     */
    msg?: string;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    queueSize: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    avgEventProcessTime?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    avgEventConcurrentProcessTime?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    rankEta?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    queueEta: number;
}
/**
 * 
 * @export
 * @interface ExtrasBatchImagesRequest
 */
export interface ExtrasBatchImagesRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    resizeMode?: ExtrasBatchImagesRequest.ResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    showExtrasResults?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    gfpganVisibility?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    codeformerVisibility?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    codeformerWeight?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    upscalingResize?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    upscalingResizeW?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    upscalingResizeH?: number;
    /**
     * Should the upscaler crop the image to fit in the chosen size?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    upscalingCrop?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    upscaler1?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    upscaler2?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    extrasUpscaler2Visibility?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    upscaleFirst?: boolean;
    /**
     * List of images to work on. Must be Base64 strings
     * @type {Array<FileData>}
     * @memberof ExtrasBatchImagesRequest
     */
    imageList: Array<FileData>;
}

/**
 * @export
 * @namespace ExtrasBatchImagesRequest
 */
export namespace ExtrasBatchImagesRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ResizeModeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface ExtrasBatchImagesResponse
 */
export interface ExtrasBatchImagesResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasBatchImagesResponse
     */
    htmlInfo: string;
    /**
     * The generated images in base64 format.
     * @type {Array<string>}
     * @memberof ExtrasBatchImagesResponse
     */
    images: Array<string>;
}
/**
 * 
 * @export
 * @interface ExtrasSingleImageRequest
 */
export interface ExtrasSingleImageRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    resizeMode?: ExtrasSingleImageRequest.ResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    showExtrasResults?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    gfpganVisibility?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    codeformerVisibility?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    codeformerWeight?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    upscalingResize?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    upscalingResizeW?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    upscalingResizeH?: number;
    /**
     * Should the upscaler crop the image to fit in the chosen size?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    upscalingCrop?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    upscaler1?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    upscaler2?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    extrasUpscaler2Visibility?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    upscaleFirst?: boolean;
    /**
     * Image to work on, must be a Base64 string containing the image's data.
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    image?: string;
}

/**
 * @export
 * @namespace ExtrasSingleImageRequest
 */
export namespace ExtrasSingleImageRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ResizeModeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface ExtrasSingleImageResponse
 */
export interface ExtrasSingleImageResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    htmlInfo: string;
    /**
     * The generated image in base64 format.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface FaceRestorerItem
 */
export interface FaceRestorerItem {
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    cmdDir?: string;
}
/**
 * 
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     * Base64 representation of the file
     * @type {string}
     * @memberof FileData
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    name: string;
}
/**
 * 
 * @export
 * @interface Flags
 */
export interface Flags {
    /**
     * base path where all user data is stored
     * @type {string}
     * @memberof Flags
     */
    dataDir?: string;
    /**
     * path to config which constructs model
     * @type {string}
     * @memberof Flags
     */
    config?: string;
    /**
     * path to checkpoint of stable diffusion model; if specified, this checkpoint will be added to the list of checkpoints and loaded
     * @type {string}
     * @memberof Flags
     */
    ckpt?: string;
    /**
     * Path to directory with stable diffusion checkpoints
     * @type {string}
     * @memberof Flags
     */
    ckptDir?: string;
    /**
     * Path to directory with VAE files
     * @type {string}
     * @memberof Flags
     */
    vaeDir?: string;
    /**
     * GFPGAN directory
     * @type {string}
     * @memberof Flags
     */
    gfpganDir?: string;
    /**
     * GFPGAN model file name
     * @type {string}
     * @memberof Flags
     */
    gfpganModel?: string;
    /**
     * do not switch the model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    noHalf?: boolean;
    /**
     * do not switch the VAE model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    noHalfVae?: boolean;
    /**
     * do not hide progressbar in gradio UI (we hide it because it slows down ML if you have hardware acceleration in browser)
     * @type {boolean}
     * @memberof Flags
     */
    noProgressbarHiding?: boolean;
    /**
     * maximum batch count value for the UI
     * @type {number}
     * @memberof Flags
     */
    maxBatchCount?: number;
    /**
     * embeddings directory for textual inversion (default: embeddings)
     * @type {string}
     * @memberof Flags
     */
    embeddingsDir?: string;
    /**
     * directory with textual inversion templates
     * @type {string}
     * @memberof Flags
     */
    textualInversionTemplatesDir?: string;
    /**
     * hypernetwork directory
     * @type {string}
     * @memberof Flags
     */
    hypernetworkDir?: string;
    /**
     * localizations directory
     * @type {string}
     * @memberof Flags
     */
    localizationsDir?: string;
    /**
     * allow custom script execution from webui
     * @type {boolean}
     * @memberof Flags
     */
    allowCode?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a little speed for low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    medvram?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a lot of speed for very low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    lowvram?: boolean;
    /**
     * load stable diffusion checkpoint weights to VRAM instead of RAM
     * @type {boolean}
     * @memberof Flags
     */
    lowram?: boolean;
    /**
     * disables cond/uncond batching that is enabled to save memory with --medvram or --lowvram
     * @type {boolean}
     * @memberof Flags
     */
    alwaysBatchCondUncond?: boolean;
    /**
     * does not do anything.
     * @type {boolean}
     * @memberof Flags
     */
    unloadGfpgan?: boolean;
    /**
     * evaluate at this precision
     * @type {string}
     * @memberof Flags
     */
    precision?: string;
    /**
     * upcast sampling. No effect with --no-half. Usually produces similar results to --no-half with better performance while using less memory.
     * @type {boolean}
     * @memberof Flags
     */
    upcastSampling?: boolean;
    /**
     * use share=True for gradio and make the UI accessible through their site
     * @type {boolean}
     * @memberof Flags
     */
    share?: boolean;
    /**
     * ngrok authtoken, alternative to gradio --share
     * @type {string}
     * @memberof Flags
     */
    ngrok?: string;
    /**
     * The region in which ngrok should start.
     * @type {string}
     * @memberof Flags
     */
    ngrokRegion?: string;
    /**
     * enable extensions tab regardless of other options
     * @type {boolean}
     * @memberof Flags
     */
    enableInsecureExtensionAccess?: boolean;
    /**
     * Path to directory with codeformer model file(s).
     * @type {string}
     * @memberof Flags
     */
    codeformerModelsPath?: string;
    /**
     * Path to directory with GFPGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    gfpganModelsPath?: string;
    /**
     * Path to directory with ESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    esrganModelsPath?: string;
    /**
     * Path to directory with BSRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    bsrganModelsPath?: string;
    /**
     * Path to directory with RealESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    realesrganModelsPath?: string;
    /**
     * Path to directory with CLIP model file(s).
     * @type {string}
     * @memberof Flags
     */
    clipModelsPath?: string;
    /**
     * enable xformers for cross attention layers
     * @type {boolean}
     * @memberof Flags
     */
    xformers?: boolean;
    /**
     * enable xformers for cross attention layers regardless of whether the checking code thinks you can run it; do not make bug reports if this fails to work
     * @type {boolean}
     * @memberof Flags
     */
    forceEnableXformers?: boolean;
    /**
     * enable xformers with Flash Attention to improve reproducibility (supported for SD2.x or variant only)
     * @type {boolean}
     * @memberof Flags
     */
    xformersFlashAttention?: boolean;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    deepdanbooru?: boolean;
    /**
     * force-enables Doggettx's cross-attention layer optimization. By default, it's on for torch cuda.
     * @type {boolean}
     * @memberof Flags
     */
    optSplitAttention?: boolean;
    /**
     * enable memory efficient sub-quadratic cross-attention layer optimization
     * @type {boolean}
     * @memberof Flags
     */
    optSubQuadAttention?: boolean;
    /**
     * query chunk size for the sub-quadratic cross-attention layer optimization to use
     * @type {number}
     * @memberof Flags
     */
    subQuadQChunkSize?: number;
    /**
     * kv chunk size for the sub-quadratic cross-attention layer optimization to use
     * @type {string}
     * @memberof Flags
     */
    subQuadKvChunkSize?: string;
    /**
     * the percentage of VRAM threshold for the sub-quadratic cross-attention layer optimization to use chunking
     * @type {string}
     * @memberof Flags
     */
    subQuadChunkThreshold?: string;
    /**
     * force-enables InvokeAI's cross-attention layer optimization. By default, it's on when cuda is unavailable.
     * @type {boolean}
     * @memberof Flags
     */
    optSplitAttentionInvokeai?: boolean;
    /**
     * enable older version of split attention optimization that does not consume all the VRAM it can find
     * @type {boolean}
     * @memberof Flags
     */
    optSplitAttentionV1?: boolean;
    /**
     * enable scaled dot product cross-attention layer optimization; requires PyTorch 2.*
     * @type {boolean}
     * @memberof Flags
     */
    optSdpAttention?: boolean;
    /**
     * enable scaled dot product cross-attention layer optimization without memory efficient attention, makes image generation deterministic; requires PyTorch 2.*
     * @type {boolean}
     * @memberof Flags
     */
    optSdpNoMemAttention?: boolean;
    /**
     * force-disables cross-attention layer optimization
     * @type {boolean}
     * @memberof Flags
     */
    disableOptSplitAttention?: boolean;
    /**
     * do not check if produced images/latent spaces have nans; useful for running without a checkpoint in CI
     * @type {boolean}
     * @memberof Flags
     */
    disableNanCheck?: boolean;
    /**
     * use CPU as torch device for specified modules
     * @type {Array<any>}
     * @memberof Flags
     */
    useCpu?: Array<any>;
    /**
     * launch gradio with 0.0.0.0 as server name, allowing to respond to network requests
     * @type {boolean}
     * @memberof Flags
     */
    listen?: boolean;
    /**
     * launch gradio with given server port, you need root/admin rights for ports < 1024, defaults to 7860 if available
     * @type {string}
     * @memberof Flags
     */
    port?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    showNegativePrompt?: boolean;
    /**
     * filename to use for ui configuration
     * @type {string}
     * @memberof Flags
     */
    uiConfigFile?: string;
    /**
     * hide directory configuration from webui
     * @type {boolean}
     * @memberof Flags
     */
    hideUiDirConfig?: boolean;
    /**
     * disable editing settings
     * @type {boolean}
     * @memberof Flags
     */
    freezeSettings?: boolean;
    /**
     * filename to use for ui settings
     * @type {string}
     * @memberof Flags
     */
    uiSettingsFile?: string;
    /**
     * launch gradio with --debug option
     * @type {boolean}
     * @memberof Flags
     */
    gradioDebug?: boolean;
    /**
     * set gradio authentication like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    gradioAuth?: string;
    /**
     * set gradio authentication file path ex. \"/path/to/auth/file\" same auth format as --gradio-auth
     * @type {string}
     * @memberof Flags
     */
    gradioAuthPath?: string;
    /**
     * does not do anything
     * @type {string}
     * @memberof Flags
     */
    gradioImg2imgTool?: string;
    /**
     * does not do anything
     * @type {string}
     * @memberof Flags
     */
    gradioInpaintTool?: string;
    /**
     * change memory type for stable diffusion to channels last
     * @type {boolean}
     * @memberof Flags
     */
    optChannelslast?: boolean;
    /**
     * filename to use for styles
     * @type {string}
     * @memberof Flags
     */
    stylesFile?: string;
    /**
     * open the webui URL in the system's default browser upon launch
     * @type {boolean}
     * @memberof Flags
     */
    autolaunch?: boolean;
    /**
     * launches the UI with light or dark theme
     * @type {string}
     * @memberof Flags
     */
    theme?: string;
    /**
     * use textbox for seeds in UI (no up/down, but possible to input long seeds)
     * @type {boolean}
     * @memberof Flags
     */
    useTextboxSeed?: boolean;
    /**
     * do not output progressbars to console
     * @type {boolean}
     * @memberof Flags
     */
    disableConsoleProgressbars?: boolean;
    /**
     * print prompts to console when generating with txt2img and img2img
     * @type {boolean}
     * @memberof Flags
     */
    enableConsolePrompts?: boolean;
    /**
     * Checkpoint to use as VAE; setting this argument disables all settings related to VAE
     * @type {string}
     * @memberof Flags
     */
    vaePath?: string;
    /**
     * disable checking pytorch models for malicious code
     * @type {boolean}
     * @memberof Flags
     */
    disableSafeUnpickle?: boolean;
    /**
     * use api=True to launch the API together with the webui (use --nowebui instead for only the API)
     * @type {boolean}
     * @memberof Flags
     */
    api?: boolean;
    /**
     * Set authentication for API like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    apiAuth?: string;
    /**
     * use api-log=True to enable logging of all API requests
     * @type {boolean}
     * @memberof Flags
     */
    apiLog?: boolean;
    /**
     * use api=True to launch the API instead of the webui
     * @type {boolean}
     * @memberof Flags
     */
    nowebui?: boolean;
    /**
     * Don't load model to quickly launch UI
     * @type {boolean}
     * @memberof Flags
     */
    uiDebugMode?: boolean;
    /**
     * Select the default CUDA device to use (export CUDA_VISIBLE_DEVICES=0,1,etc might be needed before)
     * @type {string}
     * @memberof Flags
     */
    deviceId?: string;
    /**
     * Administrator rights
     * @type {boolean}
     * @memberof Flags
     */
    administrator?: boolean;
    /**
     * Allowed CORS origin(s) in the form of a comma-separated list (no spaces)
     * @type {string}
     * @memberof Flags
     */
    corsAllowOrigins?: string;
    /**
     * Allowed CORS origin(s) in the form of a single regular expression
     * @type {string}
     * @memberof Flags
     */
    corsAllowOriginsRegex?: string;
    /**
     * Partially enables TLS, requires --tls-certfile to fully function
     * @type {string}
     * @memberof Flags
     */
    tlsKeyfile?: string;
    /**
     * Partially enables TLS, requires --tls-keyfile to fully function
     * @type {string}
     * @memberof Flags
     */
    tlsCertfile?: string;
    /**
     * Sets hostname of server
     * @type {string}
     * @memberof Flags
     */
    serverName?: string;
    /**
     * Uses gradio queue; experimental option; breaks restart UI button
     * @type {boolean}
     * @memberof Flags
     */
    gradioQueue?: boolean;
    /**
     * Do not check versions of torch and xformers
     * @type {boolean}
     * @memberof Flags
     */
    skipVersionCheck?: boolean;
    /**
     * disable sha256 hashing of checkpoints to help loading performance
     * @type {boolean}
     * @memberof Flags
     */
    noHashing?: boolean;
    /**
     * don't download SD1.5 model even if no model is found in --ckpt-dir
     * @type {boolean}
     * @memberof Flags
     */
    noDownloadSdModel?: boolean;
    /**
     * The maximum number of additional network model can be used.
     * @type {number}
     * @memberof Flags
     */
    addnetMaxModelCount?: number;
    /**
     * Path to directory with ControlNet models
     * @type {string}
     * @memberof Flags
     */
    controlnetDir?: string;
    /**
     * do not switch the ControlNet models to 16-bit floats (only needed without --no-half)
     * @type {string}
     * @memberof Flags
     */
    noHalfControlnet?: string;
    /**
     * Path to directory with LDSR model file(s).
     * @type {string}
     * @memberof Flags
     */
    ldsrModelsPath?: string;
    /**
     * Path to directory with Lora networks.
     * @type {string}
     * @memberof Flags
     */
    loraDir?: string;
    /**
     * Path to directory with ScuNET model file(s).
     * @type {string}
     * @memberof Flags
     */
    scunetModelsPath?: string;
    /**
     * Path to directory with SwinIR model file(s).
     * @type {string}
     * @memberof Flags
     */
    swinirModelsPath?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HypernetworkItem
 */
export interface HypernetworkItem {
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface ImageToImageResponse
 */
export interface ImageToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof ImageToImageResponse
     */
    images?: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof ImageToImageResponse
     */
    parameters: any;
    /**
     * 
     * @type {string}
     * @memberof ImageToImageResponse
     */
    info: string;
}
/**
 * 
 * @export
 * @interface InterrogateRequest
 */
export interface InterrogateRequest {
    /**
     * Image to work on, must be a Base64 string containing the image's data.
     * @type {string}
     * @memberof InterrogateRequest
     */
    image?: string;
    /**
     * The interrogate model used.
     * @type {string}
     * @memberof InterrogateRequest
     */
    model?: string;
}
/**
 * 
 * @export
 * @interface MemoryResponse
 */
export interface MemoryResponse {
    /**
     * System memory stats
     * @type {any}
     * @memberof MemoryResponse
     */
    ram: any;
    /**
     * nVidia CUDA memory stats
     * @type {any}
     * @memberof MemoryResponse
     */
    cuda: any;
}
/**
 * 
 * @export
 * @interface ModulesApiModelsProgressResponse
 */
export interface ModulesApiModelsProgressResponse {
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ModulesApiModelsProgressResponse
     */
    progress: number;
    /**
     * 
     * @type {number}
     * @memberof ModulesApiModelsProgressResponse
     */
    etaRelative: number;
    /**
     * The current state snapshot
     * @type {any}
     * @memberof ModulesApiModelsProgressResponse
     */
    state: any;
    /**
     * The current image in base64 format. opts.show_progress_every_n_steps is required for this to work.
     * @type {string}
     * @memberof ModulesApiModelsProgressResponse
     */
    currentImage?: string;
    /**
     * Info text used by WebUI.
     * @type {string}
     * @memberof ModulesApiModelsProgressResponse
     */
    textinfo?: string;
}
/**
 * 
 * @export
 * @interface ModulesProgressProgressResponse
 */
export interface ModulesProgressProgressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    active: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    queued: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    completed: boolean;
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    progress?: number;
    /**
     * 
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    eta?: number;
    /**
     * Current live preview; a data: uri
     * @type {string}
     * @memberof ModulesProgressProgressResponse
     */
    livePreview?: string;
    /**
     * Send this together with next request to prevent receiving same image
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    idLivePreview?: number;
    /**
     * Info text used by WebUI.
     * @type {string}
     * @memberof ModulesProgressProgressResponse
     */
    textinfo?: string;
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * Always save all generated images
     * @type {boolean}
     * @memberof Options
     */
    samplesSave?: boolean;
    /**
     * File format for images
     * @type {string}
     * @memberof Options
     */
    samplesFormat?: string;
    /**
     * Images filename pattern
     * @type {string}
     * @memberof Options
     */
    samplesFilenamePattern?: string;
    /**
     * Add number to filename when saving
     * @type {boolean}
     * @memberof Options
     */
    saveImagesAddNumber?: boolean;
    /**
     * Always save all generated image grids
     * @type {boolean}
     * @memberof Options
     */
    gridSave?: boolean;
    /**
     * File format for grids
     * @type {string}
     * @memberof Options
     */
    gridFormat?: string;
    /**
     * Add extended info (seed, prompt) to filename when saving grid
     * @type {boolean}
     * @memberof Options
     */
    gridExtendedFilename?: boolean;
    /**
     * Do not save grids consisting of one picture
     * @type {boolean}
     * @memberof Options
     */
    gridOnlyIfMultiple?: boolean;
    /**
     * Prevent empty spots in grid (when set to autodetect)
     * @type {boolean}
     * @memberof Options
     */
    gridPreventEmptySpots?: boolean;
    /**
     * Grid row count; use -1 for autodetect and 0 for it to be same as batch size
     * @type {number}
     * @memberof Options
     */
    nRows?: number;
    /**
     * Save text information about generation parameters as chunks to png files
     * @type {boolean}
     * @memberof Options
     */
    enablePnginfo?: boolean;
    /**
     * Create a text file next to every image with generation parameters.
     * @type {boolean}
     * @memberof Options
     */
    saveTxt?: boolean;
    /**
     * Save a copy of image before doing face restoration.
     * @type {boolean}
     * @memberof Options
     */
    saveImagesBeforeFaceRestoration?: boolean;
    /**
     * Save a copy of image before applying highres fix.
     * @type {boolean}
     * @memberof Options
     */
    saveImagesBeforeHighresFix?: boolean;
    /**
     * Save a copy of image before applying color correction to img2img results
     * @type {boolean}
     * @memberof Options
     */
    saveImagesBeforeColorCorrection?: boolean;
    /**
     * Quality for saved jpeg images
     * @type {number}
     * @memberof Options
     */
    jpegQuality?: number;
    /**
     * Use lossless compression for webp images
     * @type {boolean}
     * @memberof Options
     */
    webpLossless?: boolean;
    /**
     * If the saved image file size is above the limit, or its either width or height are above the limit, save a downscaled copy as JPG
     * @type {boolean}
     * @memberof Options
     */
    exportFor4chan?: boolean;
    /**
     * File size limit for the above option, MB
     * @type {number}
     * @memberof Options
     */
    imgDownscaleThreshold?: number;
    /**
     * Width/height limit for the above option, in pixels
     * @type {number}
     * @memberof Options
     */
    targetSideLength?: number;
    /**
     * Maximum image size, in megapixels
     * @type {number}
     * @memberof Options
     */
    imgMaxSizeMp?: number;
    /**
     * Use original name for output filename during batch process in extras tab
     * @type {boolean}
     * @memberof Options
     */
    useOriginalNameBatch?: boolean;
    /**
     * Use upscaler name as filename suffix in the extras tab
     * @type {boolean}
     * @memberof Options
     */
    useUpscalerNameAsSuffix?: boolean;
    /**
     * When using 'Save' button, only save a single selected image
     * @type {boolean}
     * @memberof Options
     */
    saveSelectedOnly?: boolean;
    /**
     * Do not add watermark to images
     * @type {boolean}
     * @memberof Options
     */
    doNotAddWatermark?: boolean;
    /**
     * Directory for temporary images; leave empty for default
     * @type {string}
     * @memberof Options
     */
    tempDir?: string;
    /**
     * Cleanup non-default temporary directory when starting webui
     * @type {boolean}
     * @memberof Options
     */
    cleanTempDirAtStart?: boolean;
    /**
     * Output directory for images; if empty, defaults to three directories below
     * @type {string}
     * @memberof Options
     */
    outdirSamples?: string;
    /**
     * Output directory for txt2img images
     * @type {string}
     * @memberof Options
     */
    outdirTxt2imgSamples?: string;
    /**
     * Output directory for img2img images
     * @type {string}
     * @memberof Options
     */
    outdirImg2imgSamples?: string;
    /**
     * Output directory for images from extras tab
     * @type {string}
     * @memberof Options
     */
    outdirExtrasSamples?: string;
    /**
     * Output directory for grids; if empty, defaults to two directories below
     * @type {string}
     * @memberof Options
     */
    outdirGrids?: string;
    /**
     * Output directory for txt2img grids
     * @type {string}
     * @memberof Options
     */
    outdirTxt2imgGrids?: string;
    /**
     * Output directory for img2img grids
     * @type {string}
     * @memberof Options
     */
    outdirImg2imgGrids?: string;
    /**
     * Directory for saving images using the Save button
     * @type {string}
     * @memberof Options
     */
    outdirSave?: string;
    /**
     * Save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    saveToDirs?: boolean;
    /**
     * Save grids to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    gridSaveToDirs?: boolean;
    /**
     * When using \"Save\" button, save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    useSaveToDirsForUi?: boolean;
    /**
     * Directory name pattern
     * @type {string}
     * @memberof Options
     */
    directoriesFilenamePattern?: string;
    /**
     * Max prompt words for [prompt_words] pattern
     * @type {number}
     * @memberof Options
     */
    directoriesMaxPromptWords?: number;
    /**
     * Tile size for ESRGAN upscalers. 0 = no tiling.
     * @type {number}
     * @memberof Options
     */
    eSRGANTile?: number;
    /**
     * Tile overlap, in pixels for ESRGAN upscalers. Low values = visible seam.
     * @type {number}
     * @memberof Options
     */
    eSRGANTileOverlap?: number;
    /**
     * Select which Real-ESRGAN models to show in the web UI. (Requires restart)
     * @type {Array<any>}
     * @memberof Options
     */
    realesrganEnabledModels?: Array<any>;
    /**
     * Upscaler for img2img
     * @type {ModelNull}
     * @memberof Options
     */
    upscalerForImg2img?: ModelNull;
    /**
     * Face restoration model
     * @type {ModelNull}
     * @memberof Options
     */
    faceRestorationModel?: ModelNull;
    /**
     * CodeFormer weight parameter; 0 = maximum effect; 1 = minimum effect
     * @type {number}
     * @memberof Options
     */
    codeFormerWeight?: number;
    /**
     * Move face restoration model from VRAM into RAM after processing
     * @type {boolean}
     * @memberof Options
     */
    faceRestorationUnload?: boolean;
    /**
     * Show warnings in console.
     * @type {boolean}
     * @memberof Options
     */
    showWarnings?: boolean;
    /**
     * VRAM usage polls per second during generation. Set to 0 to disable.
     * @type {number}
     * @memberof Options
     */
    memmonPollRate?: number;
    /**
     * Always print all generation info to standard output
     * @type {boolean}
     * @memberof Options
     */
    samplesLogStdout?: boolean;
    /**
     * Add a second progress bar to the console that shows progress for an entire job.
     * @type {boolean}
     * @memberof Options
     */
    multipleTqdm?: boolean;
    /**
     * Print extra hypernetwork information to console.
     * @type {boolean}
     * @memberof Options
     */
    printHypernetExtra?: boolean;
    /**
     * Move VAE and CLIP to RAM when training if possible. Saves VRAM.
     * @type {boolean}
     * @memberof Options
     */
    unloadModelsWhenTraining?: boolean;
    /**
     * Turn on pin_memory for DataLoader. Makes training slightly faster but can increase memory usage.
     * @type {boolean}
     * @memberof Options
     */
    pinMemory?: boolean;
    /**
     * Saves Optimizer state as separate *.optim file. Training of embedding or HN can be resumed with the matching optim file.
     * @type {boolean}
     * @memberof Options
     */
    saveOptimizerState?: boolean;
    /**
     * Save textual inversion and hypernet settings to a text file whenever training starts.
     * @type {boolean}
     * @memberof Options
     */
    saveTrainingSettingsToTxt?: boolean;
    /**
     * Filename word regex
     * @type {string}
     * @memberof Options
     */
    datasetFilenameWordRegex?: string;
    /**
     * Filename join string
     * @type {string}
     * @memberof Options
     */
    datasetFilenameJoinString?: string;
    /**
     * Number of repeats for a single input image per epoch; used only for displaying epoch number
     * @type {number}
     * @memberof Options
     */
    trainingImageRepeatsPerEpoch?: number;
    /**
     * Save an csv containing the loss to log directory every N steps, 0 to disable
     * @type {number}
     * @memberof Options
     */
    trainingWriteCsvEvery?: number;
    /**
     * Use cross attention optimizations while training
     * @type {boolean}
     * @memberof Options
     */
    trainingXattentionOptimizations?: boolean;
    /**
     * Enable tensorboard logging.
     * @type {boolean}
     * @memberof Options
     */
    trainingEnableTensorboard?: boolean;
    /**
     * Save generated images within tensorboard.
     * @type {boolean}
     * @memberof Options
     */
    trainingTensorboardSaveImages?: boolean;
    /**
     * How often, in seconds, to flush the pending tensorboard events and summaries to disk.
     * @type {number}
     * @memberof Options
     */
    trainingTensorboardFlushEvery?: number;
    /**
     * Stable Diffusion checkpoint
     * @type {string}
     * @memberof Options
     */
    sdModelCheckpoint?: string;
    /**
     * Checkpoints to cache in RAM
     * @type {number}
     * @memberof Options
     */
    sdCheckpointCache?: number;
    /**
     * VAE Checkpoints to cache in RAM
     * @type {number}
     * @memberof Options
     */
    sdVaeCheckpointCache?: number;
    /**
     * SD VAE
     * @type {string}
     * @memberof Options
     */
    sdVae?: string;
    /**
     * Ignore selected VAE for stable diffusion checkpoints that have their own .vae.pt next to them
     * @type {boolean}
     * @memberof Options
     */
    sdVaeAsDefault?: boolean;
    /**
     * Inpainting conditioning mask strength
     * @type {number}
     * @memberof Options
     */
    inpaintingMaskWeight?: number;
    /**
     * Noise multiplier for img2img
     * @type {number}
     * @memberof Options
     */
    initialNoiseMultiplier?: number;
    /**
     * Apply color correction to img2img results to match original colors.
     * @type {boolean}
     * @memberof Options
     */
    img2imgColorCorrection?: boolean;
    /**
     * With img2img, do exactly the amount of steps the slider specifies (normally you'd do less with less denoising).
     * @type {boolean}
     * @memberof Options
     */
    img2imgFixSteps?: boolean;
    /**
     * With img2img, fill image's transparent parts with this color.
     * @type {string}
     * @memberof Options
     */
    img2imgBackgroundColor?: string;
    /**
     * Enable quantization in K samplers for sharper and cleaner results. This may change existing seeds. Requires restart to apply.
     * @type {boolean}
     * @memberof Options
     */
    enableQuantization?: boolean;
    /**
     * Emphasis: use (text) to make model pay more attention to text and [text] to make it pay less attention
     * @type {boolean}
     * @memberof Options
     */
    enableEmphasis?: boolean;
    /**
     * Make K-diffusion samplers produce same images in a batch as when making a single image
     * @type {boolean}
     * @memberof Options
     */
    enableBatchSeeds?: boolean;
    /**
     * Increase coherency by padding from the last comma within n tokens when using more than 75 tokens
     * @type {number}
     * @memberof Options
     */
    commaPaddingBacktrack?: number;
    /**
     * Clip skip
     * @type {number}
     * @memberof Options
     */
    cLIPStopAtLastLayers?: number;
    /**
     * Upcast cross attention layer to float32
     * @type {boolean}
     * @memberof Options
     */
    upcastAttn?: boolean;
    /**
     * Use old emphasis implementation. Can be useful to reproduce old seeds.
     * @type {boolean}
     * @memberof Options
     */
    useOldEmphasisImplementation?: boolean;
    /**
     * Use old karras scheduler sigmas (0.1 to 10).
     * @type {boolean}
     * @memberof Options
     */
    useOldKarrasSchedulerSigmas?: boolean;
    /**
     * Do not make DPM++ SDE deterministic across different batch sizes.
     * @type {boolean}
     * @memberof Options
     */
    noDpmppSdeBatchDeterminism?: boolean;
    /**
     * For hires fix, use width/height sliders to set final resolution rather than first pass (disables Upscale by, Resize width/height to).
     * @type {boolean}
     * @memberof Options
     */
    useOldHiresFixWidthHeight?: boolean;
    /**
     * Interrogate: keep models in VRAM
     * @type {boolean}
     * @memberof Options
     */
    interrogateKeepModelsInMemory?: boolean;
    /**
     * Interrogate: include ranks of model tags matches in results (Has no effect on caption-based interrogators).
     * @type {boolean}
     * @memberof Options
     */
    interrogateReturnRanks?: boolean;
    /**
     * Interrogate: num_beams for BLIP
     * @type {number}
     * @memberof Options
     */
    interrogateClipNumBeams?: number;
    /**
     * Interrogate: minimum description length (excluding artists, etc..)
     * @type {number}
     * @memberof Options
     */
    interrogateClipMinLength?: number;
    /**
     * Interrogate: maximum description length
     * @type {number}
     * @memberof Options
     */
    interrogateClipMaxLength?: number;
    /**
     * CLIP: maximum number of lines in text file (0 = No limit)
     * @type {number}
     * @memberof Options
     */
    interrogateClipDictLimit?: number;
    /**
     * CLIP: skip inquire categories
     * @type {Array<any>}
     * @memberof Options
     */
    interrogateClipSkipCategories?: Array<any>;
    /**
     * Interrogate: deepbooru score threshold
     * @type {number}
     * @memberof Options
     */
    interrogateDeepbooruScoreThreshold?: number;
    /**
     * Interrogate: deepbooru sort alphabetically
     * @type {boolean}
     * @memberof Options
     */
    deepbooruSortAlpha?: boolean;
    /**
     * use spaces for tags in deepbooru
     * @type {boolean}
     * @memberof Options
     */
    deepbooruUseSpaces?: boolean;
    /**
     * escape (\\) brackets in deepbooru (so they are used as literal brackets and not for emphasis)
     * @type {boolean}
     * @memberof Options
     */
    deepbooruEscape?: boolean;
    /**
     * filter out those tags from deepbooru output (separated by comma)
     * @type {string}
     * @memberof Options
     */
    deepbooruFilterTags?: string;
    /**
     * Default view for Extra Networks
     * @type {string}
     * @memberof Options
     */
    extraNetworksDefaultView?: string;
    /**
     * Multiplier for extra networks
     * @type {number}
     * @memberof Options
     */
    extraNetworksDefaultMultiplier?: number;
    /**
     * Extra text to add before <...> when adding extra network to prompt
     * @type {string}
     * @memberof Options
     */
    extraNetworksAddTextSeparator?: string;
    /**
     * Add hypernetwork to prompt
     * @type {string}
     * @memberof Options
     */
    sdHypernetwork?: string;
    /**
     * Show grid in results for web
     * @type {boolean}
     * @memberof Options
     */
    returnGrid?: boolean;
    /**
     * Do not show any images in results for web
     * @type {boolean}
     * @memberof Options
     */
    doNotShowImages?: boolean;
    /**
     * Add model hash to generation information
     * @type {boolean}
     * @memberof Options
     */
    addModelHashToInfo?: boolean;
    /**
     * Add model name to generation information
     * @type {boolean}
     * @memberof Options
     */
    addModelNameToInfo?: boolean;
    /**
     * When reading generation parameters from text into UI (from PNG info or pasted text), do not change the selected model/checkpoint.
     * @type {boolean}
     * @memberof Options
     */
    disableWeightsAutoSwap?: boolean;
    /**
     * Send seed when sending prompt or image to other interface
     * @type {boolean}
     * @memberof Options
     */
    sendSeed?: boolean;
    /**
     * Send size when sending prompt or image to another interface
     * @type {boolean}
     * @memberof Options
     */
    sendSize?: boolean;
    /**
     * Font for image grids that have text
     * @type {string}
     * @memberof Options
     */
    font?: string;
    /**
     * Enable full page image viewer
     * @type {boolean}
     * @memberof Options
     */
    jsModalLightbox?: boolean;
    /**
     * Show images zoomed in by default in full page image viewer
     * @type {boolean}
     * @memberof Options
     */
    jsModalLightboxInitiallyZoomed?: boolean;
    /**
     * Show generation progress in window title.
     * @type {boolean}
     * @memberof Options
     */
    showProgressInTitle?: boolean;
    /**
     * Use dropdown for sampler selection instead of radio group
     * @type {boolean}
     * @memberof Options
     */
    samplersInDropdown?: boolean;
    /**
     * Show Width/Height and Batch sliders in same row
     * @type {boolean}
     * @memberof Options
     */
    dimensionsAndBatchTogether?: boolean;
    /**
     * Ctrl+up/down precision when editing (attention:1.1)
     * @type {number}
     * @memberof Options
     */
    keyeditPrecisionAttention?: number;
    /**
     * Ctrl+up/down precision when editing <extra networks:0.9>
     * @type {number}
     * @memberof Options
     */
    keyeditPrecisionExtra?: number;
    /**
     * Quicksettings list
     * @type {string}
     * @memberof Options
     */
    quicksettings?: string;
    /**
     * Hidden UI tabs (requires restart)
     * @type {Array<any>}
     * @memberof Options
     */
    hiddenTabs?: Array<any>;
    /**
     * txt2img/img2img UI item order
     * @type {string}
     * @memberof Options
     */
    uiReorder?: string;
    /**
     * Extra networks tab order
     * @type {string}
     * @memberof Options
     */
    uiExtraNetworksTabReorder?: string;
    /**
     * Localization (requires restart)
     * @type {string}
     * @memberof Options
     */
    localization?: string;
    /**
     * Show progressbar
     * @type {boolean}
     * @memberof Options
     */
    showProgressbar?: boolean;
    /**
     * Show live previews of the created image
     * @type {boolean}
     * @memberof Options
     */
    livePreviewsEnable?: boolean;
    /**
     * Show previews of all images generated in a batch as a grid
     * @type {boolean}
     * @memberof Options
     */
    showProgressGrid?: boolean;
    /**
     * Show new live preview image every N sampling steps. Set to -1 to show after completion of batch.
     * @type {number}
     * @memberof Options
     */
    showProgressEveryNSteps?: number;
    /**
     * Image creation progress preview mode
     * @type {string}
     * @memberof Options
     */
    showProgressType?: string;
    /**
     * Live preview subject
     * @type {string}
     * @memberof Options
     */
    livePreviewContent?: string;
    /**
     * Progressbar/preview update period, in milliseconds
     * @type {number}
     * @memberof Options
     */
    livePreviewRefreshPeriod?: number;
    /**
     * Hide samplers in user interface (requires restart)
     * @type {Array<any>}
     * @memberof Options
     */
    hideSamplers?: Array<any>;
    /**
     * eta (noise multiplier) for DDIM
     * @type {number}
     * @memberof Options
     */
    etaDdim?: number;
    /**
     * eta (noise multiplier) for ancestral samplers
     * @type {number}
     * @memberof Options
     */
    etaAncestral?: number;
    /**
     * img2img DDIM discretize
     * @type {string}
     * @memberof Options
     */
    ddimDiscretize?: string;
    /**
     * sigma churn
     * @type {number}
     * @memberof Options
     */
    sChurn?: number;
    /**
     * sigma tmin
     * @type {number}
     * @memberof Options
     */
    sTmin?: number;
    /**
     * sigma noise
     * @type {number}
     * @memberof Options
     */
    sNoise?: number;
    /**
     * Eta noise seed delta
     * @type {number}
     * @memberof Options
     */
    etaNoiseSeedDelta?: number;
    /**
     * Always discard next-to-last sigma
     * @type {boolean}
     * @memberof Options
     */
    alwaysDiscardNextToLastSigma?: boolean;
    /**
     * UniPC variant
     * @type {string}
     * @memberof Options
     */
    uniPcVariant?: string;
    /**
     * UniPC skip type
     * @type {string}
     * @memberof Options
     */
    uniPcSkipType?: string;
    /**
     * UniPC order (must be < sampling steps)
     * @type {number}
     * @memberof Options
     */
    uniPcOrder?: number;
    /**
     * UniPC lower order final
     * @type {boolean}
     * @memberof Options
     */
    uniPcLowerOrderFinal?: boolean;
    /**
     * Enable postprocessing operations in txt2img and img2img tabs
     * @type {Array<any>}
     * @memberof Options
     */
    postprocessingEnableInMainUi?: Array<any>;
    /**
     * Postprocessing operation order
     * @type {Array<any>}
     * @memberof Options
     */
    postprocessingOperationOrder?: Array<any>;
    /**
     * Maximum number of images in upscaling cache
     * @type {number}
     * @memberof Options
     */
    upscalingMaxImagesInCache?: number;
    /**
     * Disable those extensions
     * @type {Array<any>}
     * @memberof Options
     */
    disabledExtensions?: Array<any>;
    /**
     * SHA256 hash of the current checkpoint
     * @type {string}
     * @memberof Options
     */
    sdCheckpointHash?: string;
    /**
     * Add Lora to prompt
     * @type {string}
     * @memberof Options
     */
    sdLora?: string;
    /**
     * Apply Lora to outputs rather than inputs when possible (experimental)
     * @type {boolean}
     * @memberof Options
     */
    loraApplyToOutputs?: boolean;
}
/**
 * 
 * @export
 * @interface PNGInfoRequest
 */
export interface PNGInfoRequest {
    /**
     * The base64 encoded PNG image
     * @type {string}
     * @memberof PNGInfoRequest
     */
    image: string;
}
/**
 * 
 * @export
 * @interface PNGInfoResponse
 */
export interface PNGInfoResponse {
    /**
     * A string with the parameters used to generate the image
     * @type {string}
     * @memberof PNGInfoResponse
     */
    info: string;
    /**
     * An object containing all the info the image had
     * @type {any}
     * @memberof PNGInfoResponse
     */
    items: any;
}
/**
 * 
 * @export
 * @interface PredictBody
 */
export interface PredictBody {
    /**
     * 
     * @type {string}
     * @memberof PredictBody
     */
    sessionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof PredictBody
     */
    eventId?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof PredictBody
     */
    data: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof PredictBody
     */
    fnIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PredictBody
     */
    batched?: boolean;
    /**
     * 
     * @type {any | Array<any>}
     * @memberof PredictBody
     */
    request?: any | Array<any>;
}
/**
 * 
 * @export
 * @interface PreprocessResponse
 */
export interface PreprocessResponse {
    /**
     * Response string from preprocessing task.
     * @type {string}
     * @memberof PreprocessResponse
     */
    info: string;
}
/**
 * 
 * @export
 * @interface ProgressRequest
 */
export interface ProgressRequest {
    /**
     * id of the task to get progress for
     * @type {string}
     * @memberof ProgressRequest
     */
    idTask?: string;
    /**
     * id of last received last preview image
     * @type {number}
     * @memberof ProgressRequest
     */
    idLivePreview?: number;
}
/**
 * 
 * @export
 * @interface PromptStyleItem
 */
export interface PromptStyleItem {
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    prompt?: string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    negativePrompt?: string;
}
/**
 * 
 * @export
 * @interface RealesrganItem
 */
export interface RealesrganItem {
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof RealesrganItem
     */
    scale?: number;
}
/**
 * 
 * @export
 * @interface ResetBody
 */
export interface ResetBody {
    /**
     * 
     * @type {string}
     * @memberof ResetBody
     */
    sessionHash: string;
    /**
     * 
     * @type {number}
     * @memberof ResetBody
     */
    fnIndex: number;
}
/**
 * 
 * @export
 * @interface SDModelItem
 */
export interface SDModelItem {
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    modelName: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    sha256?: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    filename: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    config?: string;
}
/**
 * 
 * @export
 * @interface SamplerItem
 */
export interface SamplerItem {
    /**
     * 
     * @type {string}
     * @memberof SamplerItem
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SamplerItem
     */
    aliases: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SamplerItem
     */
    options: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ScriptsList
 */
export interface ScriptsList {
    /**
     * Titles of scripts (txt2img)
     * @type {Array<any>}
     * @memberof ScriptsList
     */
    txt2img?: Array<any>;
    /**
     * Titles of scripts (img2img)
     * @type {Array<any>}
     * @memberof ScriptsList
     */
    img2img?: Array<any>;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingImg2Img
 */
export interface StableDiffusionProcessingImg2Img {
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    initImages?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    resizeMode?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    denoisingStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    imageCfgScale?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    mask?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    maskBlur?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    inpaintingFill?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    inpaintFullRes?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    inpaintFullResPadding?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    inpaintingMaskInvert?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    initialNoiseMultiplier?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    prompt?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    styles?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    subseed?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    subseedStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    seedResizeFromH?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    seedResizeFromW?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    samplerName?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    batchSize?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    nIter?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    steps?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    cfgScale?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    restoreFaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    tiling?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    doNotSaveSamples?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    doNotSaveGrid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    negativePrompt?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    eta?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    sChurn?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    sTmax?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    sTmin?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    sNoise?: number;
    /**
     * 
     * @type {any}
     * @memberof StableDiffusionProcessingImg2Img
     */
    overrideSettings?: any;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    overrideSettingsRestoreAfterwards?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    scriptArgs?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    samplerIndex?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    includeInitImages?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    scriptName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    sendImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    saveImages?: boolean;
    /**
     * 
     * @type {any}
     * @memberof StableDiffusionProcessingImg2Img
     */
    alwaysonScripts?: any;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingTxt2Img
 */
export interface StableDiffusionProcessingTxt2Img {
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    enableHr?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    denoisingStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    firstphaseWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    firstphaseHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    hrScale?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    hrUpscaler?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    hrSecondPassSteps?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    hrResizeX?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    hrResizeY?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    prompt?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    styles?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    subseed?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    subseedStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    seedResizeFromH?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    seedResizeFromW?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    samplerName?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    batchSize?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    nIter?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    steps?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    cfgScale?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    restoreFaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    tiling?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    doNotSaveSamples?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    doNotSaveGrid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    negativePrompt?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    eta?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    sChurn?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    sTmax?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    sTmin?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    sNoise?: number;
    /**
     * 
     * @type {any}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    overrideSettings?: any;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    overrideSettingsRestoreAfterwards?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    scriptArgs?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    samplerIndex?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    scriptName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    sendImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    saveImages?: boolean;
    /**
     * 
     * @type {any}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    alwaysonScripts?: any;
}
/**
 * 
 * @export
 * @interface TextToImageResponse
 */
export interface TextToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof TextToImageResponse
     */
    images?: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof TextToImageResponse
     */
    parameters: any;
    /**
     * 
     * @type {string}
     * @memberof TextToImageResponse
     */
    info: string;
}
/**
 * 
 * @export
 * @interface TrainResponse
 */
export interface TrainResponse {
    /**
     * Response string from train embedding or hypernetwork task.
     * @type {string}
     * @memberof TrainResponse
     */
    info: string;
}
/**
 * 
 * @export
 * @interface UpscalerItem
 */
export interface UpscalerItem {
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    modelName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    modelPath?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    modelUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof UpscalerItem
     */
    scale?: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * AutoPhotoshopSDPluginAPIApi - fetch parameter creator
 * @export
 */
export const AutoPhotoshopSDPluginAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Changesdurl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/sd_url/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getinitimagehandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/getInitImage/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionSdapiAutoPhotoshopSdVersionGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Img2Imghandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/img2img/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loadhistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/history/load`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loadpromptshortcut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/prompt_shortcut/load`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loadpromptshortcut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/prompt_shortcut/save`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Maskexpansionhandler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/mask/expansion/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Openurl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openUrlSdapiAutoPhotoshopSdOpenUrlPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/open/url/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootSdapiAutoPhotoshopSdGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Savepng
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePngSdapiAutoPhotoshopSdSavePngPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/save/png/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sdapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdConfigGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sdapi
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling sdapiSdapiAutoPhotoshopSdSdapiV1PathGet.');
            }
            const localVarPath = `/sdapi/auto-photoshop-sd/sdapi/v1/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sdapi
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling sdapiSdapiAutoPhotoshopSdSdapiV1PathPost.');
            }
            const localVarPath = `/sdapi/auto-photoshop-sd/sdapi/v1/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searchimage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageSdapiAutoPhotoshopSdSearchImagePost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/search/image/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Swapmodel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapModelSdapiAutoPhotoshopSdSwapModelPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/swapModel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Txt2Imghandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/auto-photoshop-sd/txt2img/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoPhotoshopSDPluginAPIApi - functional programming interface
 * @export
 */
export const AutoPhotoshopSDPluginAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Changesdurl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Getinitimagehandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Getversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionSdapiAutoPhotoshopSdVersionGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).getVersionSdapiAutoPhotoshopSdVersionGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Img2Imghandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Loadhistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Loadpromptshortcut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Loadpromptshortcut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Maskexpansionhandler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Openurl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openUrlSdapiAutoPhotoshopSdOpenUrlPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).openUrlSdapiAutoPhotoshopSdOpenUrlPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootSdapiAutoPhotoshopSdGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).readRootSdapiAutoPhotoshopSdGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Savepng
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePngSdapiAutoPhotoshopSdSavePngPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).savePngSdapiAutoPhotoshopSdSavePngPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sdapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdConfigGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).sdapiSdapiAutoPhotoshopSdConfigGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sdapi
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sdapi
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Searchimage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageSdapiAutoPhotoshopSdSearchImagePost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).searchImageSdapiAutoPhotoshopSdSearchImagePost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Swapmodel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapModelSdapiAutoPhotoshopSdSwapModelPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).swapModelSdapiAutoPhotoshopSdSwapModelPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Txt2Imghandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AutoPhotoshopSDPluginAPIApiFetchParamCreator(configuration).txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AutoPhotoshopSDPluginAPIApi - factory interface
 * @export
 */
export const AutoPhotoshopSDPluginAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Changesdurl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Getinitimagehandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Getversion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionSdapiAutoPhotoshopSdVersionGet(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).getVersionSdapiAutoPhotoshopSdVersionGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Img2Imghandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Loadhistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Loadpromptshortcut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Loadpromptshortcut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Maskexpansionhandler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Openurl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openUrlSdapiAutoPhotoshopSdOpenUrlPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).openUrlSdapiAutoPhotoshopSdOpenUrlPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootSdapiAutoPhotoshopSdGet(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).readRootSdapiAutoPhotoshopSdGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Savepng
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePngSdapiAutoPhotoshopSdSavePngPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).savePngSdapiAutoPhotoshopSdSavePngPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sdapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdConfigGet(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).sdapiSdapiAutoPhotoshopSdConfigGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sdapi
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path: string, options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sdapi
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path: string, options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Searchimage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageSdapiAutoPhotoshopSdSearchImagePost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).searchImageSdapiAutoPhotoshopSdSearchImagePost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Swapmodel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapModelSdapiAutoPhotoshopSdSwapModelPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).swapModelSdapiAutoPhotoshopSdSwapModelPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Txt2Imghandle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options?: any) {
            return AutoPhotoshopSDPluginAPIApiFp(configuration).txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options)(fetch, basePath);
        },
    };
};

/**
 * AutoPhotoshopSDPluginAPIApi - object-oriented interface
 * @export
 * @class AutoPhotoshopSDPluginAPIApi
 * @extends {BaseAPI}
 */
export class AutoPhotoshopSDPluginAPIApi extends BaseAPI {
    /**
     * 
     * @summary Changesdurl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).changeSdUrlSdapiAutoPhotoshopSdSdUrlPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Getinitimagehandle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).getInitImageHandleSdapiAutoPhotoshopSdGetInitImagePost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Getversion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public getVersionSdapiAutoPhotoshopSdVersionGet(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).getVersionSdapiAutoPhotoshopSdVersionGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Img2Imghandle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).img2ImgHandleSdapiAutoPhotoshopSdImg2imgPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Loadhistory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).loadHistorySdapiAutoPhotoshopSdHistoryLoadPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Loadpromptshortcut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutLoadPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Loadpromptshortcut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).loadPromptShortcutSdapiAutoPhotoshopSdPromptShortcutSavePost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Maskexpansionhandler
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).maskExpansionHandlerSdapiAutoPhotoshopSdMaskExpansionPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Openurl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public openUrlSdapiAutoPhotoshopSdOpenUrlPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).openUrlSdapiAutoPhotoshopSdOpenUrlPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public readRootSdapiAutoPhotoshopSdGet(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).readRootSdapiAutoPhotoshopSdGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Savepng
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public savePngSdapiAutoPhotoshopSdSavePngPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).savePngSdapiAutoPhotoshopSdSavePngPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sdapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public sdapiSdapiAutoPhotoshopSdConfigGet(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).sdapiSdapiAutoPhotoshopSdConfigGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sdapi
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path: string, options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).sdapiSdapiAutoPhotoshopSdSdapiV1PathGet(path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sdapi
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path: string, options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).sdapiSdapiAutoPhotoshopSdSdapiV1PathPost(path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Searchimage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public searchImageSdapiAutoPhotoshopSdSearchImagePost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).searchImageSdapiAutoPhotoshopSdSearchImagePost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Swapmodel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public swapModelSdapiAutoPhotoshopSdSwapModelPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).swapModelSdapiAutoPhotoshopSdSwapModelPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Txt2Imghandle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoPhotoshopSDPluginAPIApi
     */
    public txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options?: any) {
        return AutoPhotoshopSDPluginAPIApiFp(this.configuration).txt2ImgHandleSdapiAutoPhotoshopSdTxt2imgPost(options)(this.fetch, this.basePath);
    }

}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet(options: any = {}): FetchArgs {
            const localVarPath = `/app_id/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_1(options: any = {}): FetchArgs {
            const localVarPath = `/app_id`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet(path: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling buildResourceAssetsPathGet.');
            }
            const localVarPath = `/assets/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Controlnet Img2Img
         * @param {ControlNetStableDiffusionProcessingImg2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlnetImg2imgControlnetImg2imgPost(body: ControlNetStableDiffusionProcessingImg2Img, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling controlnetImg2imgControlnetImg2imgPost.');
            }
            const localVarPath = `/controlnet/img2img`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ControlNetStableDiffusionProcessingImg2Img" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Controlnet Txt2Img
         * @param {ControlNetStableDiffusionProcessingTxt2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlnetTxt2imgControlnetTxt2imgPost(body: ControlNetStableDiffusionProcessingTxt2Img, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling controlnetTxt2imgControlnetTxt2imgPost.');
            }
            const localVarPath = `/controlnet/txt2img`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ControlNetStableDiffusionProcessingTxt2Img" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Embedding
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createEmbeddingSdapiV1CreateEmbeddingPost.');
            }
            const localVarPath = `/sdapi/v1/create/embedding`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createHypernetworkSdapiV1CreateHypernetworkPost.');
            }
            const localVarPath = `/sdapi/v1/create/hypernetwork`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detect
         * @param {BodyDetectControlnetDetectPost} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectControlnetDetectPost(body?: BodyDetectControlnetDetectPost, options: any = {}): FetchArgs {
            const localVarPath = `/controlnet/detect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BodyDetectControlnetDetectPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body: ExtrasBatchImagesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling extrasBatchImagesApiSdapiV1ExtraBatchImagesPost.');
            }
            const localVarPath = `/sdapi/v1/extra-batch-images`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExtrasBatchImagesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost(body: ExtrasSingleImageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling extrasSingleImageApiSdapiV1ExtraSingleImagePost.');
            }
            const localVarPath = `/sdapi/v1/extra-single-image`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExtrasSingleImageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet(options: any = {}): FetchArgs {
            const localVarPath = `/favicon.ico`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet(filename?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sd_extra_networks/thumb`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet(path: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling fileDeprecatedFilePathGet.');
            }
            const localVarPath = `/file/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathGet(path: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling fileFilePathGet.');
            }
            const localVarPath = `/file={path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/cmd-flags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet(options: any = {}): FetchArgs {
            const localVarPath = `/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_2(options: any = {}): FetchArgs {
            const localVarPath = `/config/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/options`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet(options: any = {}): FetchArgs {
            const localVarPath = `/user/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_3(options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/embeddings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/face-restorers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/hypernetworks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/memory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/prompt-styles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet(options: any = {}): FetchArgs {
            const localVarPath = `/queue/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/realesrgan-models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/samplers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/scripts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/sd-models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet(options: any = {}): FetchArgs {
            const localVarPath = `/token/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_4(options: any = {}): FetchArgs {
            const localVarPath = `/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/upscalers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost(body: StableDiffusionProcessingImg2Img, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling img2imgapiSdapiV1Img2imgPost.');
            }
            const localVarPath = `/sdapi/v1/img2img`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StableDiffusionProcessingImg2Img" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost(body: InterrogateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling interrogateapiSdapiV1InterrogatePost.');
            }
            const localVarPath = `/sdapi/v1/interrogate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InterrogateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/interrupt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet(options: any = {}): FetchArgs {
            const localVarPath = `/login_check/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_5(options: any = {}): FetchArgs {
            const localVarPath = `/login_check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options: any = {}): FetchArgs {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling loginLoginPost.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling loginLoginPost.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginLoginPost.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling loginLoginPost.');
            }
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling loginLoginPost.');
            }
            // verify required parameter 'clientSecret' is not null or undefined
            if (clientSecret === null || clientSecret === undefined) {
                throw new RequiredError('clientSecret','Required parameter clientSecret was null or undefined when calling loginLoginPost.');
            }
            const localVarPath = `/login/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (username !== undefined) {
                localVarFormParams.set('username', username as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            if (scope !== undefined) {
                localVarFormParams.set('scope', scope as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_6(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options: any = {}): FetchArgs {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling loginLoginPost_6.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling loginLoginPost_6.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginLoginPost_6.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling loginLoginPost_6.');
            }
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling loginLoginPost_6.');
            }
            // verify required parameter 'clientSecret' is not null or undefined
            if (clientSecret === null || clientSecret === undefined) {
                throw new RequiredError('clientSecret','Required parameter clientSecret was null or undefined when calling loginLoginPost_6.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (username !== undefined) {
                localVarFormParams.set('username', username as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            if (scope !== undefined) {
                localVarFormParams.set('scope', scope as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Model List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelListControlnetModelListGet(options: any = {}): FetchArgs {
            const localVarPath = `/controlnet/model_list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Module List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleListControlnetModuleListGet(options: any = {}): FetchArgs {
            const localVarPath = `/controlnet/module_list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost(body: PNGInfoRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pnginfoapiSdapiV1PngInfoPost.');
            }
            const localVarPath = `/sdapi/v1/png-info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PNGInfoRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost(body: PredictBody, apiName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling predictApiApiNamePost.');
            }
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling predictApiApiNamePost.');
            }
            const localVarPath = `/api/{api_name}/`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredictBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_7(body: PredictBody, apiName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling predictApiApiNamePost_7.');
            }
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling predictApiApiNamePost_7.');
            }
            const localVarPath = `/api/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredictBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost(body: PredictBody, apiName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling predictRunApiNamePost.');
            }
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling predictRunApiNamePost.');
            }
            const localVarPath = `/run/{api_name}/`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredictBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_8(body: PredictBody, apiName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling predictRunApiNamePost_8.');
            }
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling predictRunApiNamePost_8.');
            }
            const localVarPath = `/run/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PredictBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preprocess
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preprocessSdapiV1PreprocessPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling preprocessSdapiV1PreprocessPost.');
            }
            const localVarPath = `/sdapi/v1/preprocess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost(body: ProgressRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling progressapiInternalProgressPost.');
            }
            const localVarPath = `/internal/progress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/progress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCurrentImage !== undefined) {
                localVarQueryParameter['skip_current_image'] = skipCurrentImage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/refresh-checkpoints`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost(body: ResetBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resetIteratorResetPost.');
            }
            const localVarPath = `/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_9(body: ResetBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resetIteratorResetPost_9.');
            }
            const localVarPath = `/reset/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet(options: any = {}): FetchArgs {
            const localVarPath = `/robots.txt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Config
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setConfigSdapiV1OptionsPost.');
            }
            const localVarPath = `/sdapi/v1/options`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost(options: any = {}): FetchArgs {
            const localVarPath = `/sdapi/v1/skip`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet(options: any = {}): FetchArgs {
            const localVarPath = `/startup-events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet(path: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling staticResourceStaticPathGet.');
            }
            const localVarPath = `/static/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost(body: StableDiffusionProcessingTxt2Img, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling text2imgapiSdapiV1Txt2imgPost.');
            }
            const localVarPath = `/sdapi/v1/txt2img`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StableDiffusionProcessingTxt2Img" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Train Embedding
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling trainEmbeddingSdapiV1TrainEmbeddingPost.');
            }
            const localVarPath = `/sdapi/v1/train/embedding`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling trainHypernetworkSdapiV1TrainHypernetworkPost.');
            }
            const localVarPath = `/sdapi/v1/train/hypernetwork`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionControlnetVersionGet(options: any = {}): FetchArgs {
            const localVarPath = `/controlnet/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).appIdAppIdGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).appIdAppIdGet_1(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet(path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).buildResourceAssetsPathGet(path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Controlnet Img2Img
         * @param {ControlNetStableDiffusionProcessingImg2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlnetImg2imgControlnetImg2imgPost(body: ControlNetStableDiffusionProcessingImg2Img, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImageToImageResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).controlnetImg2imgControlnetImg2imgPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Controlnet Txt2Img
         * @param {ControlNetStableDiffusionProcessingTxt2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlnetTxt2imgControlnetTxt2imgPost(body: ControlNetStableDiffusionProcessingTxt2Img, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TextToImageResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).controlnetTxt2imgControlnetTxt2imgPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create Embedding
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createEmbeddingSdapiV1CreateEmbeddingPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createHypernetworkSdapiV1CreateHypernetworkPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Detect
         * @param {BodyDetectControlnetDetectPost} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectControlnetDetectPost(body?: BodyDetectControlnetDetectPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).detectControlnetDetectPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body: ExtrasBatchImagesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExtrasBatchImagesResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost(body: ExtrasSingleImageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExtrasSingleImageResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).extrasSingleImageApiSdapiV1ExtraSingleImagePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).faviconFaviconIcoGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet(filename?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).fetchFileSdExtraNetworksThumbGet(filename, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet(path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).fileDeprecatedFilePathGet(path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary File
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathGet(path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).fileFilePathGet(path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flags> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCmdFlagsSdapiV1CmdFlagsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getConfigConfigGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getConfigConfigGet_2(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Options> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getConfigSdapiV1OptionsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCurrentUserUserGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_3(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCurrentUserUserGet_3(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmbeddingsResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getEmbeddingsSdapiV1EmbeddingsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FaceRestorerItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getFaceRestorersSdapiV1FaceRestorersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<HypernetworkItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getHypernetworksSdapiV1HypernetworksGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MemoryResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getMemorySdapiV1MemoryGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PromptStyleItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getPromptStylesSdapiV1PromptStylesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Estimation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getQueueStatusQueueStatusGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RealesrganItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getRealesrganModelsSdapiV1RealesrganModelsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SamplerItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getSamplersSdapiV1SamplersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScriptsList> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getScriptsListSdapiV1ScriptsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SDModelItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getSdModelsSdapiV1SdModelsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getTokenTokenGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_4(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getTokenTokenGet_4(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UpscalerItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getUpscalersSdapiV1UpscalersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost(body: StableDiffusionProcessingImg2Img, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImageToImageResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).img2imgapiSdapiV1Img2imgPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost(body: InterrogateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).interrogateapiSdapiV1InterrogatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).interruptapiSdapiV1InterruptPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).loginCheckLoginCheckGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_5(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).loginCheckLoginCheckGet_5(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).loginLoginPost(grantType, username, password, scope, clientId, clientSecret, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_6(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).loginLoginPost_6(grantType, username, password, scope, clientId, clientSecret, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mainGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mainHead(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Model List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelListControlnetModelListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).modelListControlnetModelListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Module List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleListControlnetModuleListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).moduleListControlnetModuleListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost(body: PNGInfoRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PNGInfoResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).pnginfoapiSdapiV1PngInfoPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost(body: PredictBody, apiName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).predictApiApiNamePost(body, apiName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_7(body: PredictBody, apiName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).predictApiApiNamePost_7(body, apiName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost(body: PredictBody, apiName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).predictRunApiNamePost(body, apiName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_8(body: PredictBody, apiName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).predictRunApiNamePost_8(body, apiName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Preprocess
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preprocessSdapiV1PreprocessPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PreprocessResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).preprocessSdapiV1PreprocessPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost(body: ProgressRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModulesProgressProgressResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).progressapiInternalProgressPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModulesApiModelsProgressResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).progressapiSdapiV1ProgressGet(skipCurrentImage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).refreshCheckpointsSdapiV1RefreshCheckpointsPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost(body: ResetBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).resetIteratorResetPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_9(body: ResetBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).resetIteratorResetPost_9(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).robotsTxtRobotsTxtGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set Config
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setConfigSdapiV1OptionsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).skipSdapiV1SkipPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).startupEventsStartupEventsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet(path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).staticResourceStaticPathGet(path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost(body: StableDiffusionProcessingTxt2Img, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TextToImageResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).text2imgapiSdapiV1Txt2imgPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Train Embedding
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TrainResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).trainEmbeddingSdapiV1TrainEmbeddingPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TrainResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).trainHypernetworkSdapiV1TrainHypernetworkPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionControlnetVersionGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).versionControlnetVersionGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet(options?: any) {
            return DefaultApiFp(configuration).appIdAppIdGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_1(options?: any) {
            return DefaultApiFp(configuration).appIdAppIdGet_1(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet(path: string, options?: any) {
            return DefaultApiFp(configuration).buildResourceAssetsPathGet(path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Controlnet Img2Img
         * @param {ControlNetStableDiffusionProcessingImg2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlnetImg2imgControlnetImg2imgPost(body: ControlNetStableDiffusionProcessingImg2Img, options?: any) {
            return DefaultApiFp(configuration).controlnetImg2imgControlnetImg2imgPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Controlnet Txt2Img
         * @param {ControlNetStableDiffusionProcessingTxt2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlnetTxt2imgControlnetTxt2imgPost(body: ControlNetStableDiffusionProcessingTxt2Img, options?: any) {
            return DefaultApiFp(configuration).controlnetTxt2imgControlnetTxt2imgPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create Embedding
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost(body: any, options?: any) {
            return DefaultApiFp(configuration).createEmbeddingSdapiV1CreateEmbeddingPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost(body: any, options?: any) {
            return DefaultApiFp(configuration).createHypernetworkSdapiV1CreateHypernetworkPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Detect
         * @param {BodyDetectControlnetDetectPost} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectControlnetDetectPost(body?: BodyDetectControlnetDetectPost, options?: any) {
            return DefaultApiFp(configuration).detectControlnetDetectPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body: ExtrasBatchImagesRequest, options?: any) {
            return DefaultApiFp(configuration).extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost(body: ExtrasSingleImageRequest, options?: any) {
            return DefaultApiFp(configuration).extrasSingleImageApiSdapiV1ExtraSingleImagePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet(options?: any) {
            return DefaultApiFp(configuration).faviconFaviconIcoGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet(filename?: string, options?: any) {
            return DefaultApiFp(configuration).fetchFileSdExtraNetworksThumbGet(filename, options)(fetch, basePath);
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet(path: string, options?: any) {
            return DefaultApiFp(configuration).fileDeprecatedFilePathGet(path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary File
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathGet(path: string, options?: any) {
            return DefaultApiFp(configuration).fileFilePathGet(path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet(options?: any) {
            return DefaultApiFp(configuration).getCmdFlagsSdapiV1CmdFlagsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet(options?: any) {
            return DefaultApiFp(configuration).getConfigConfigGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_2(options?: any) {
            return DefaultApiFp(configuration).getConfigConfigGet_2(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet(options?: any) {
            return DefaultApiFp(configuration).getConfigSdapiV1OptionsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet(options?: any) {
            return DefaultApiFp(configuration).getCurrentUserUserGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_3(options?: any) {
            return DefaultApiFp(configuration).getCurrentUserUserGet_3(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet(options?: any) {
            return DefaultApiFp(configuration).getEmbeddingsSdapiV1EmbeddingsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet(options?: any) {
            return DefaultApiFp(configuration).getFaceRestorersSdapiV1FaceRestorersGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet(options?: any) {
            return DefaultApiFp(configuration).getHypernetworksSdapiV1HypernetworksGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet(options?: any) {
            return DefaultApiFp(configuration).getMemorySdapiV1MemoryGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet(options?: any) {
            return DefaultApiFp(configuration).getPromptStylesSdapiV1PromptStylesGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet(options?: any) {
            return DefaultApiFp(configuration).getQueueStatusQueueStatusGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet(options?: any) {
            return DefaultApiFp(configuration).getRealesrganModelsSdapiV1RealesrganModelsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet(options?: any) {
            return DefaultApiFp(configuration).getSamplersSdapiV1SamplersGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet(options?: any) {
            return DefaultApiFp(configuration).getScriptsListSdapiV1ScriptsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet(options?: any) {
            return DefaultApiFp(configuration).getSdModelsSdapiV1SdModelsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet(options?: any) {
            return DefaultApiFp(configuration).getTokenTokenGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_4(options?: any) {
            return DefaultApiFp(configuration).getTokenTokenGet_4(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet(options?: any) {
            return DefaultApiFp(configuration).getUpscalersSdapiV1UpscalersGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost(body: StableDiffusionProcessingImg2Img, options?: any) {
            return DefaultApiFp(configuration).img2imgapiSdapiV1Img2imgPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost(body: InterrogateRequest, options?: any) {
            return DefaultApiFp(configuration).interrogateapiSdapiV1InterrogatePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost(options?: any) {
            return DefaultApiFp(configuration).interruptapiSdapiV1InterruptPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet(options?: any) {
            return DefaultApiFp(configuration).loginCheckLoginCheckGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_5(options?: any) {
            return DefaultApiFp(configuration).loginCheckLoginCheckGet_5(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any) {
            return DefaultApiFp(configuration).loginLoginPost(grantType, username, password, scope, clientId, clientSecret, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_6(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any) {
            return DefaultApiFp(configuration).loginLoginPost_6(grantType, username, password, scope, clientId, clientSecret, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options?: any) {
            return DefaultApiFp(configuration).mainGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead(options?: any) {
            return DefaultApiFp(configuration).mainHead(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Model List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelListControlnetModelListGet(options?: any) {
            return DefaultApiFp(configuration).modelListControlnetModelListGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Module List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleListControlnetModuleListGet(options?: any) {
            return DefaultApiFp(configuration).moduleListControlnetModuleListGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost(body: PNGInfoRequest, options?: any) {
            return DefaultApiFp(configuration).pnginfoapiSdapiV1PngInfoPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost(body: PredictBody, apiName: string, options?: any) {
            return DefaultApiFp(configuration).predictApiApiNamePost(body, apiName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_7(body: PredictBody, apiName: string, options?: any) {
            return DefaultApiFp(configuration).predictApiApiNamePost_7(body, apiName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost(body: PredictBody, apiName: string, options?: any) {
            return DefaultApiFp(configuration).predictRunApiNamePost(body, apiName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {PredictBody} body 
         * @param {string} apiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_8(body: PredictBody, apiName: string, options?: any) {
            return DefaultApiFp(configuration).predictRunApiNamePost_8(body, apiName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Preprocess
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preprocessSdapiV1PreprocessPost(body: any, options?: any) {
            return DefaultApiFp(configuration).preprocessSdapiV1PreprocessPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost(body: ProgressRequest, options?: any) {
            return DefaultApiFp(configuration).progressapiInternalProgressPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: any) {
            return DefaultApiFp(configuration).progressapiSdapiV1ProgressGet(skipCurrentImage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: any) {
            return DefaultApiFp(configuration).refreshCheckpointsSdapiV1RefreshCheckpointsPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost(body: ResetBody, options?: any) {
            return DefaultApiFp(configuration).resetIteratorResetPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_9(body: ResetBody, options?: any) {
            return DefaultApiFp(configuration).resetIteratorResetPost_9(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet(options?: any) {
            return DefaultApiFp(configuration).robotsTxtRobotsTxtGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set Config
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost(body: any, options?: any) {
            return DefaultApiFp(configuration).setConfigSdapiV1OptionsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost(options?: any) {
            return DefaultApiFp(configuration).skipSdapiV1SkipPost(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet(options?: any) {
            return DefaultApiFp(configuration).startupEventsStartupEventsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet(path: string, options?: any) {
            return DefaultApiFp(configuration).staticResourceStaticPathGet(path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost(body: StableDiffusionProcessingTxt2Img, options?: any) {
            return DefaultApiFp(configuration).text2imgapiSdapiV1Txt2imgPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Train Embedding
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost(body: any, options?: any) {
            return DefaultApiFp(configuration).trainEmbeddingSdapiV1TrainEmbeddingPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost(body: any, options?: any) {
            return DefaultApiFp(configuration).trainHypernetworkSdapiV1TrainHypernetworkPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionControlnetVersionGet(options?: any) {
            return DefaultApiFp(configuration).versionControlnetVersionGet(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary App Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appIdAppIdGet(options?: any) {
        return DefaultApiFp(this.configuration).appIdAppIdGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary App Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appIdAppIdGet_1(options?: any) {
        return DefaultApiFp(this.configuration).appIdAppIdGet_1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Build Resource
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public buildResourceAssetsPathGet(path: string, options?: any) {
        return DefaultApiFp(this.configuration).buildResourceAssetsPathGet(path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Controlnet Img2Img
     * @param {ControlNetStableDiffusionProcessingImg2Img} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public controlnetImg2imgControlnetImg2imgPost(body: ControlNetStableDiffusionProcessingImg2Img, options?: any) {
        return DefaultApiFp(this.configuration).controlnetImg2imgControlnetImg2imgPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Controlnet Txt2Img
     * @param {ControlNetStableDiffusionProcessingTxt2Img} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public controlnetTxt2imgControlnetTxt2imgPost(body: ControlNetStableDiffusionProcessingTxt2Img, options?: any) {
        return DefaultApiFp(this.configuration).controlnetTxt2imgControlnetTxt2imgPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create Embedding
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createEmbeddingSdapiV1CreateEmbeddingPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).createEmbeddingSdapiV1CreateEmbeddingPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create Hypernetwork
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createHypernetworkSdapiV1CreateHypernetworkPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).createHypernetworkSdapiV1CreateHypernetworkPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Detect
     * @param {BodyDetectControlnetDetectPost} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public detectControlnetDetectPost(body?: BodyDetectControlnetDetectPost, options?: any) {
        return DefaultApiFp(this.configuration).detectControlnetDetectPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Extras Batch Images Api
     * @param {ExtrasBatchImagesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body: ExtrasBatchImagesRequest, options?: any) {
        return DefaultApiFp(this.configuration).extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Extras Single Image Api
     * @param {ExtrasSingleImageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extrasSingleImageApiSdapiV1ExtraSingleImagePost(body: ExtrasSingleImageRequest, options?: any) {
        return DefaultApiFp(this.configuration).extrasSingleImageApiSdapiV1ExtraSingleImagePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Favicon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public faviconFaviconIcoGet(options?: any) {
        return DefaultApiFp(this.configuration).faviconFaviconIcoGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch File
     * @param {string} [filename] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fetchFileSdExtraNetworksThumbGet(filename?: string, options?: any) {
        return DefaultApiFp(this.configuration).fetchFileSdExtraNetworksThumbGet(filename, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary File Deprecated
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fileDeprecatedFilePathGet(path: string, options?: any) {
        return DefaultApiFp(this.configuration).fileDeprecatedFilePathGet(path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary File
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fileFilePathGet(path: string, options?: any) {
        return DefaultApiFp(this.configuration).fileFilePathGet(path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Cmd Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCmdFlagsSdapiV1CmdFlagsGet(options?: any) {
        return DefaultApiFp(this.configuration).getCmdFlagsSdapiV1CmdFlagsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigConfigGet(options?: any) {
        return DefaultApiFp(this.configuration).getConfigConfigGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigConfigGet_2(options?: any) {
        return DefaultApiFp(this.configuration).getConfigConfigGet_2(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigSdapiV1OptionsGet(options?: any) {
        return DefaultApiFp(this.configuration).getConfigSdapiV1OptionsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUserUserGet(options?: any) {
        return DefaultApiFp(this.configuration).getCurrentUserUserGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUserUserGet_3(options?: any) {
        return DefaultApiFp(this.configuration).getCurrentUserUserGet_3(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Embeddings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEmbeddingsSdapiV1EmbeddingsGet(options?: any) {
        return DefaultApiFp(this.configuration).getEmbeddingsSdapiV1EmbeddingsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Face Restorers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFaceRestorersSdapiV1FaceRestorersGet(options?: any) {
        return DefaultApiFp(this.configuration).getFaceRestorersSdapiV1FaceRestorersGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Hypernetworks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHypernetworksSdapiV1HypernetworksGet(options?: any) {
        return DefaultApiFp(this.configuration).getHypernetworksSdapiV1HypernetworksGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Memory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMemorySdapiV1MemoryGet(options?: any) {
        return DefaultApiFp(this.configuration).getMemorySdapiV1MemoryGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Prompt Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPromptStylesSdapiV1PromptStylesGet(options?: any) {
        return DefaultApiFp(this.configuration).getPromptStylesSdapiV1PromptStylesGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Queue Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQueueStatusQueueStatusGet(options?: any) {
        return DefaultApiFp(this.configuration).getQueueStatusQueueStatusGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Realesrgan Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRealesrganModelsSdapiV1RealesrganModelsGet(options?: any) {
        return DefaultApiFp(this.configuration).getRealesrganModelsSdapiV1RealesrganModelsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Samplers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSamplersSdapiV1SamplersGet(options?: any) {
        return DefaultApiFp(this.configuration).getSamplersSdapiV1SamplersGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Scripts List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getScriptsListSdapiV1ScriptsGet(options?: any) {
        return DefaultApiFp(this.configuration).getScriptsListSdapiV1ScriptsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Sd Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSdModelsSdapiV1SdModelsGet(options?: any) {
        return DefaultApiFp(this.configuration).getSdModelsSdapiV1SdModelsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenTokenGet(options?: any) {
        return DefaultApiFp(this.configuration).getTokenTokenGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenTokenGet_4(options?: any) {
        return DefaultApiFp(this.configuration).getTokenTokenGet_4(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Upscalers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUpscalersSdapiV1UpscalersGet(options?: any) {
        return DefaultApiFp(this.configuration).getUpscalersSdapiV1UpscalersGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Img2Imgapi
     * @param {StableDiffusionProcessingImg2Img} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public img2imgapiSdapiV1Img2imgPost(body: StableDiffusionProcessingImg2Img, options?: any) {
        return DefaultApiFp(this.configuration).img2imgapiSdapiV1Img2imgPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Interrogateapi
     * @param {InterrogateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public interrogateapiSdapiV1InterrogatePost(body: InterrogateRequest, options?: any) {
        return DefaultApiFp(this.configuration).interrogateapiSdapiV1InterrogatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Interruptapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public interruptapiSdapiV1InterruptPost(options?: any) {
        return DefaultApiFp(this.configuration).interruptapiSdapiV1InterruptPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginCheckLoginCheckGet(options?: any) {
        return DefaultApiFp(this.configuration).loginCheckLoginCheckGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginCheckLoginCheckGet_5(options?: any) {
        return DefaultApiFp(this.configuration).loginCheckLoginCheckGet_5(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login
     * @param {string} grantType 
     * @param {string} username 
     * @param {string} password 
     * @param {string} scope 
     * @param {string} clientId 
     * @param {string} clientSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginLoginPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any) {
        return DefaultApiFp(this.configuration).loginLoginPost(grantType, username, password, scope, clientId, clientSecret, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login
     * @param {string} grantType 
     * @param {string} username 
     * @param {string} password 
     * @param {string} scope 
     * @param {string} clientId 
     * @param {string} clientSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginLoginPost_6(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any) {
        return DefaultApiFp(this.configuration).loginLoginPost_6(grantType, username, password, scope, clientId, clientSecret, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mainGet(options?: any) {
        return DefaultApiFp(this.configuration).mainGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mainHead(options?: any) {
        return DefaultApiFp(this.configuration).mainHead(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Model List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public modelListControlnetModelListGet(options?: any) {
        return DefaultApiFp(this.configuration).modelListControlnetModelListGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Module List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleListControlnetModuleListGet(options?: any) {
        return DefaultApiFp(this.configuration).moduleListControlnetModuleListGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Pnginfoapi
     * @param {PNGInfoRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pnginfoapiSdapiV1PngInfoPost(body: PNGInfoRequest, options?: any) {
        return DefaultApiFp(this.configuration).pnginfoapiSdapiV1PngInfoPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Predict
     * @param {PredictBody} body 
     * @param {string} apiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictApiApiNamePost(body: PredictBody, apiName: string, options?: any) {
        return DefaultApiFp(this.configuration).predictApiApiNamePost(body, apiName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Predict
     * @param {PredictBody} body 
     * @param {string} apiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictApiApiNamePost_7(body: PredictBody, apiName: string, options?: any) {
        return DefaultApiFp(this.configuration).predictApiApiNamePost_7(body, apiName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Predict
     * @param {PredictBody} body 
     * @param {string} apiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictRunApiNamePost(body: PredictBody, apiName: string, options?: any) {
        return DefaultApiFp(this.configuration).predictRunApiNamePost(body, apiName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Predict
     * @param {PredictBody} body 
     * @param {string} apiName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictRunApiNamePost_8(body: PredictBody, apiName: string, options?: any) {
        return DefaultApiFp(this.configuration).predictRunApiNamePost_8(body, apiName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Preprocess
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public preprocessSdapiV1PreprocessPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).preprocessSdapiV1PreprocessPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Progressapi
     * @param {ProgressRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public progressapiInternalProgressPost(body: ProgressRequest, options?: any) {
        return DefaultApiFp(this.configuration).progressapiInternalProgressPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Progressapi
     * @param {boolean} [skipCurrentImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).progressapiSdapiV1ProgressGet(skipCurrentImage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Refresh Checkpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: any) {
        return DefaultApiFp(this.configuration).refreshCheckpointsSdapiV1RefreshCheckpointsPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reset Iterator
     * @param {ResetBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetIteratorResetPost(body: ResetBody, options?: any) {
        return DefaultApiFp(this.configuration).resetIteratorResetPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reset Iterator
     * @param {ResetBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetIteratorResetPost_9(body: ResetBody, options?: any) {
        return DefaultApiFp(this.configuration).resetIteratorResetPost_9(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Robots Txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public robotsTxtRobotsTxtGet(options?: any) {
        return DefaultApiFp(this.configuration).robotsTxtRobotsTxtGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set Config
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setConfigSdapiV1OptionsPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).setConfigSdapiV1OptionsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public skipSdapiV1SkipPost(options?: any) {
        return DefaultApiFp(this.configuration).skipSdapiV1SkipPost(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Startup Events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startupEventsStartupEventsGet(options?: any) {
        return DefaultApiFp(this.configuration).startupEventsStartupEventsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Static Resource
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public staticResourceStaticPathGet(path: string, options?: any) {
        return DefaultApiFp(this.configuration).staticResourceStaticPathGet(path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Text2Imgapi
     * @param {StableDiffusionProcessingTxt2Img} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public text2imgapiSdapiV1Txt2imgPost(body: StableDiffusionProcessingTxt2Img, options?: any) {
        return DefaultApiFp(this.configuration).text2imgapiSdapiV1Txt2imgPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Train Embedding
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public trainEmbeddingSdapiV1TrainEmbeddingPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).trainEmbeddingSdapiV1TrainEmbeddingPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Train Hypernetwork
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public trainHypernetworkSdapiV1TrainHypernetworkPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).trainHypernetworkSdapiV1TrainHypernetworkPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public versionControlnetVersionGet(options?: any) {
        return DefaultApiFp(this.configuration).versionControlnetVersionGet(options)(this.fetch, this.basePath);
    }

}
